var documenterSearchIndex = {"docs":
[{"location":"matrix-vector/#Matrix/vector-representation","page":"Matrix/vector representation","title":"Matrix/vector representation","text":"","category":"section"},{"location":"matrix-vector/","page":"Matrix/vector representation","title":"Matrix/vector representation","text":"HYPRE.jl defines the structs HYPREMatrix and HYPREVector representing HYPREs datastructures. Specifically it uses the IJ System Interface which can be used for general sparse matrices.","category":"page"},{"location":"matrix-vector/","page":"Matrix/vector representation","title":"Matrix/vector representation","text":"HYPREMatrix and HYPREVector can be constructed either by assembling directly, or by first assembling into a Julia datastructure and the converting it. These various methods are outlined in the following sections:","category":"page"},{"location":"matrix-vector/","page":"Matrix/vector representation","title":"Matrix/vector representation","text":"Pages = [\"matrix-vector.md\"]\nDepth = 2:2","category":"page"},{"location":"matrix-vector/#Direct-assembly-(multi-/single-process)","page":"Matrix/vector representation","title":"Direct assembly (multi-/single-process)","text":"","category":"section"},{"location":"matrix-vector/","page":"Matrix/vector representation","title":"Matrix/vector representation","text":"Creating HYPREMatrix and/or HYPREVector directly is possible by first creating an assembler which is used to add all individual contributions to the matrix/vector. The required steps are:","category":"page"},{"location":"matrix-vector/","page":"Matrix/vector representation","title":"Matrix/vector representation","text":"Create a new matrix and/or vector using the constructor.\nCreate an assembler and initialize the assembling procedure using HYPRE.start_assemble!.\nAssemble all non-zero contributions (e.g. element matrix/vector in a finite element simulation) using HYPRE.assemble!.\nFinalize the assembly using HYPRE.finish_assemble!.","category":"page"},{"location":"matrix-vector/","page":"Matrix/vector representation","title":"Matrix/vector representation","text":"After these steps the matrix and vector are ready to pass to the solver. In case of multiple consecutive solves with the same sparsity pattern (e.g. multiple Newton steps, multiple time steps, ...) it is possible to reuse the same matrix by simply skipping the first step above.","category":"page"},{"location":"matrix-vector/","page":"Matrix/vector representation","title":"Matrix/vector representation","text":"Example pseudocode","category":"page"},{"location":"matrix-vector/","page":"Matrix/vector representation","title":"Matrix/vector representation","text":"# MPI communicator\ncomm = MPI.COMM_WORLD # MPI.COMM_SELF for single-process setups\n\n# Create empty matrix and vector -- this process owns rows ilower to iupper\nA = HYPREMatrix(comm, ilower, iupper)\nb = HYPREVector(comm, ilower, iupper)\n\n# Create assembler\nassembler = HYPRE.start_assemble!(A, b)\n\n# Assemble contributions from all elements owned by this process\nfor element in owned_elements\n    Ae, be = compute_element_contribution(...)\n    global_indices = get_global_indices(...)\n    HYPRE.assemble!(assembler, global_indices, Ae, be)\nend\n\n# Finalize the assembly\nA, b = HYPRE.finish_assemble!(assembler)","category":"page"},{"location":"matrix-vector/#Create-from-PartitionedArrays.jl-(multi-process)","page":"Matrix/vector representation","title":"Create from PartitionedArrays.jl (multi-process)","text":"","category":"section"},{"location":"matrix-vector/","page":"Matrix/vector representation","title":"Matrix/vector representation","text":"HYPRE.jl integrates seemlessly with PSparseMatrix and PVector from the PartitionedArrays.jl package. These can be passed directly to solve and solve!. Internally this will construct a HYPREMatrix and HYPREVectors and then convert the solution back to a PVector.","category":"page"},{"location":"matrix-vector/","page":"Matrix/vector representation","title":"Matrix/vector representation","text":"The HYPREMatrix constructor support both SparseMatrixCSC and SparseMatrixCSR as storage backends for the PSparseMatrix. However, since HYPREs internal storage is also CSR based it can be slightly more resource efficient to use SparseMatrixCSR.","category":"page"},{"location":"matrix-vector/","page":"Matrix/vector representation","title":"Matrix/vector representation","text":"The constructors also support both PartitionedArrays.jl backends: When using the MPI backend the communicator of the PSparseMatrix/PVector is used also for the HYPREMatrix/HYPREVector, and when using the Sequential backend it is assumed to be a single-process setup, and the MPI.COMM_SELF communicator is used.","category":"page"},{"location":"matrix-vector/","page":"Matrix/vector representation","title":"Matrix/vector representation","text":"Example pseudocode","category":"page"},{"location":"matrix-vector/","page":"Matrix/vector representation","title":"Matrix/vector representation","text":"# Assemble linear system (see documentation for PartitionedArrays)\nA = PSparseMatrix(...)\nb = PVector(...)\n\n# Solve with zero initial guess\nx = solve(solver, A, b)\n\n# Inplace solve with x as initial guess\nx = PVector(...)\nsolve!(solver, x, A, b)","category":"page"},{"location":"matrix-vector/","page":"Matrix/vector representation","title":"Matrix/vector representation","text":"","category":"page"},{"location":"matrix-vector/","page":"Matrix/vector representation","title":"Matrix/vector representation","text":"It is also possible to construct the arrays explicitly. This can save some resources when performing multiple consecutive solves (multiple time steps, Newton iterations, etc). To copy data back and forth between PSparseMatrix/PVector and HYPREMatrix/HYPREVector use the copy! function.","category":"page"},{"location":"matrix-vector/","page":"Matrix/vector representation","title":"Matrix/vector representation","text":"Example pseudocode","category":"page"},{"location":"matrix-vector/","page":"Matrix/vector representation","title":"Matrix/vector representation","text":"A = PSparseMatrix(...)\nx = PVector(...)\nb = PVector(...)\n\n# Construct the HYPRE arrays\nA_h = HYPREMatrix(A)\nx_h = HYPREVector(x)\nb_h = HYPREVector(b)\n\n# Solve\nsolve!(solver, x_h, A_h, b_h)\n\n# Copy solution back to x\ncopy!(x, x_h)","category":"page"},{"location":"matrix-vector/#Create-from-SparseMatrixCSC-/-SparseMatrixCSR-(single-process)","page":"Matrix/vector representation","title":"Create from SparseMatrixCSC / SparseMatrixCSR (single-process)","text":"","category":"section"},{"location":"matrix-vector/","page":"Matrix/vector representation","title":"Matrix/vector representation","text":"HYPRE.jl also support working directly with SparseMatrixCSC (from the SparseArrays.jl standard library) and SparseMatrixCSR (from the SparseMatricesCSR.jl package). This makes it possible to use solvers and preconditioners even for single-process problems. When using these type of spars matrices it is assumed that the right hand side and solution vectors are regular Julia Vectors.","category":"page"},{"location":"matrix-vector/","page":"Matrix/vector representation","title":"Matrix/vector representation","text":"Just like when using the PartitionedArrays.jl package, it is possible to pass sparse matrices directly to solve and solve!, but it is also possible to create HYPREMatrix and HYPREVector explicitly, possibly saving some resources when doing multiple consecutive linear solves (see previous section).","category":"page"},{"location":"matrix-vector/","page":"Matrix/vector representation","title":"Matrix/vector representation","text":"Example pseudocode","category":"page"},{"location":"matrix-vector/","page":"Matrix/vector representation","title":"Matrix/vector representation","text":"A = SparseMatrixCSC(...)\nx = Vector(...)\nb = Vector(...)\n\n# Solve with zero initial guess\nx = solve(solver, A, b)\n\n# Inplace solve with x as initial guess\nx = zeros(length(b))\nsolve!(solver, x, A, b)","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Initialization-and-configuration","page":"API","title":"Initialization and configuration","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"HYPRE.Init","category":"page"},{"location":"api/#HYPRE.Init","page":"API","title":"HYPRE.Init","text":"Init(; finalize_atexit=true)\n\nWrapper around HYPRE_Init. If finalize_atexit is true a Julia exit hook is added, which calls HYPRE_Finalize. This method will also call MPI.Init unless MPI is already initialized.\n\nNote: This function must be called before using HYPRE functions.\n\n\n\n\n\n","category":"function"},{"location":"api/#Matrix/vector-creation","page":"API","title":"Matrix/vector creation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"HYPRE.start_assemble!\nHYPRE.assemble!\nHYPRE.finish_assemble!","category":"page"},{"location":"api/#HYPRE.start_assemble!","page":"API","title":"HYPRE.start_assemble!","text":"HYPRE.start_assemble!(A::HYPREMatrix)                 -> HYPREMatrixAssembler\nHYPRE.start_assemble!(b::HYPREVector)                 -> HYPREVectorAssembler\nHYPRE.start_assemble!(A::HYPREMatrix, b::HYPREVector) -> HYPREAssembler\n\nInitialize a new assembly for matrix A, vector b, or for both. This zeroes out any previous data in the arrays. Return a HYPREAssembler with allocated data buffers needed to perform the assembly efficiently.\n\nSee also: HYPRE.assemble!, HYPRE.finish_assemble!.\n\n\n\n\n\n","category":"function"},{"location":"api/#HYPRE.assemble!","page":"API","title":"HYPRE.assemble!","text":"HYPRE.assemble!(A::HYPREMatrixAssembler, i, j, a::Matrix)\nHYPRE.assemble!(A::HYPREVectorAssembler, i,    b::Vector)\nHYPRE.assemble!(A::HYPREAssembler,       ij,   a::Matrix, b::Vector)\n\nAssemble (by adding) matrix contribution a, vector contribution b, into the underlying array(s) of the assembler at global row indices i and column indices j.\n\nThis is roughly equivalent to:\n\n# A.A::HYPREMatrix\nA.A[i, j] += a\n\n# A.b::HYPREVector\nA.b[i] += b\n\nSee also: HYPRE.start_assemble!, HYPRE.finish_assemble!.\n\n\n\n\n\n","category":"function"},{"location":"api/#HYPRE.finish_assemble!","page":"API","title":"HYPRE.finish_assemble!","text":"HYPRE.finish_assemble!(A::HYPREMatrixAssembler)\nHYPRE.finish_assemble!(A::HYPREVectorAssembler)\nHYPRE.finish_assemble!(A::HYPREAssembler)\n\nFinish the assembly. This synchronizes the data between processors.\n\n\n\n\n\n","category":"function"},{"location":"api/#Solvers-and-preconditioners","page":"API","title":"Solvers and preconditioners","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"HYPRE.solve!\nHYPRE.solve","category":"page"},{"location":"api/#HYPRE.solve!","page":"API","title":"HYPRE.solve!","text":"solve!(solver::HYPRESolver, x::HYPREVector, A::HYPREMatrix, b::HYPREVector)\n\nSolve the linear system A x = b using solver with x as the initial guess. The approximate solution is stored in x.\n\nSee also solve.\n\n\n\n\n\n","category":"function"},{"location":"api/#HYPRE.solve","page":"API","title":"HYPRE.solve","text":"solve(solver::HYPRESolver, A::HYPREMatrix, b::HYPREVector) -> HYPREVector\n\nSolve the linear system A x = b using solver and return the approximate solution.\n\nThis method allocates an initial guess/output vector x, initialized to 0.\n\nSee also solve!.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"HYPRE.HYPRESolver\nHYPRE.BiCGSTAB\nHYPRE.BoomerAMG\nHYPRE.FlexGMRES\nHYPRE.GMRES\nHYPRE.Hybrid\nHYPRE.ILU\nHYPRE.PCG\nHYPRE.ParaSails","category":"page"},{"location":"api/#HYPRE.HYPRESolver","page":"API","title":"HYPRE.HYPRESolver","text":"HYPRESolver\n\nAbstract super type of all the wrapped HYPRE solvers.\n\n\n\n\n\n","category":"type"},{"location":"api/#HYPRE.BiCGSTAB","page":"API","title":"HYPRE.BiCGSTAB","text":"BiCGSTAB(; settings...)\n\nCreate a BiCGSTAB solver. See HYPRE API reference for details and supported settings.\n\nExternal links\n\nBiCGSTAB API reference\n\n\n\n\n\n","category":"type"},{"location":"api/#HYPRE.BoomerAMG","page":"API","title":"HYPRE.BoomerAMG","text":"BoomerAMG(; settings...)\n\nCreate a BoomerAMG solver/preconditioner. See HYPRE API reference for details and supported settings.\n\nExternal links\n\nBoomerAMG documentation\nBoomerAMG API reference\n\n\n\n\n\n","category":"type"},{"location":"api/#HYPRE.FlexGMRES","page":"API","title":"HYPRE.FlexGMRES","text":"FlexGMRES(; settings...)\n\nCreate a FlexGMRES solver. See HYPRE API reference for details and supported settings.\n\nExternal links\n\nFlexGMRES API reference\n\n\n\n\n\n","category":"type"},{"location":"api/#HYPRE.GMRES","page":"API","title":"HYPRE.GMRES","text":"GMRES(; settings...)\n\nCreate a GMRES solver. See HYPRE API reference for details and supported settings.\n\nExternal links\n\nGMRES API reference\n\n\n\n\n\n","category":"type"},{"location":"api/#HYPRE.Hybrid","page":"API","title":"HYPRE.Hybrid","text":"Hybrid(; settings...)\n\nCreate a Hybrid solver. See HYPRE API reference for details and supported settings.\n\nExternal links\n\nHybrid documentation\nHybrid API reference\n\n\n\n\n\n","category":"type"},{"location":"api/#HYPRE.ILU","page":"API","title":"HYPRE.ILU","text":"ILU(; settings...)\n\nCreate a ILU solver/preconditioner. See HYPRE API reference for details and supported settings.\n\nExternal links\n\nILU documentation\nILU API reference\n\n\n\n\n\n","category":"type"},{"location":"api/#HYPRE.PCG","page":"API","title":"HYPRE.PCG","text":"PCG(; settings...)\n\nCreate a PCG solver. See HYPRE API reference for details and supported settings.\n\nExternal links\n\nPCG API reference\n\n\n\n\n\n","category":"type"},{"location":"api/#HYPRE.ParaSails","page":"API","title":"HYPRE.ParaSails","text":"ParaSails(comm=MPI.COMM_WORLD; settings...)\n\nCreate a ParaSails preconditioner. See HYPRE API reference for details and supported settings.\n\nExternal links\n\nParaSails documentation\nParaSails API reference\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"HYPRE.GetNumIterations\nHYPRE.GetFinalRelativeResidualNorm","category":"page"},{"location":"api/#HYPRE.GetNumIterations","page":"API","title":"HYPRE.GetNumIterations","text":"HYPRE.GetNumIterations(s::HYPRESolver)\n\nReturn number of iterations during the last solve with solver s.\n\nThis function dispatches on the solver to the corresponding C API wrapper LibHYPRE.HYPRE_$(Solver)GetNumIterations.\n\n\n\n\n\n","category":"function"},{"location":"api/#HYPRE.GetFinalRelativeResidualNorm","page":"API","title":"HYPRE.GetFinalRelativeResidualNorm","text":"HYPRE.GetFinalRelativeResidualNorm(s::HYPRESolver)\n\nReturn the final relative residual norm from the last solve with solver s.\n\nThis function dispatches on the solver to the corresponding C API wrapper LibHYPRE.HYPRE_$(Solver)GetFinalRelativeResidualNorm.\n\n\n\n\n\n","category":"function"},{"location":"solvers-preconditioners/#Solvers-and-preconditioners","page":"Solvers and preconditioners","title":"Solvers and preconditioners","text":"","category":"section"},{"location":"solvers-preconditioners/","page":"Solvers and preconditioners","title":"Solvers and preconditioners","text":"HYPRE.jl wraps most of HYPREs ParCSR solvers and preconditioners.","category":"page"},{"location":"solvers-preconditioners/","page":"Solvers and preconditioners","title":"Solvers and preconditioners","text":"The synopsis for creating and using HYPRE.jl's solver wrappers is the same for all solvers:","category":"page"},{"location":"solvers-preconditioners/","page":"Solvers and preconditioners","title":"Solvers and preconditioners","text":"Set up the linear system (see Matrix/vector representation)\n(Optional) Configure a preconditioner\nConfigure a solver\nUse HYPRE.solve or HYPRE.solve! to solve the system","category":"page"},{"location":"solvers-preconditioners/","page":"Solvers and preconditioners","title":"Solvers and preconditioners","text":"Here is the corresponding pseudo-code:","category":"page"},{"location":"solvers-preconditioners/","page":"Solvers and preconditioners","title":"Solvers and preconditioners","text":"# 1. Setup up linear system\nA = HYPREMatrix(...)\nb = HYPREVector(...)\n\n# 2. Configure a preconditioner\nprecond = HYPRESolver(; settings...)\n\n# 3. Configure a solver\nsolver = HYPRESolver(; Precond = precond, settings...)\n\n# 4. Solve the system\nx = HYPRE.solve(solver, A, b)","category":"page"},{"location":"solvers-preconditioners/","page":"Solvers and preconditioners","title":"Solvers and preconditioners","text":"The following solvers/preconditioners are currently available:","category":"page"},{"location":"solvers-preconditioners/","page":"Solvers and preconditioners","title":"Solvers and preconditioners","text":"HYPRE.BiCGSTAB\nHYPRE.BoomerAMG\nHYPRE.FlexGMRES\nHYPRE.GMRES\nHYPRE.Hybrid\nHYPRE.ILU\nHYPRE.ParaSails\nHYPRE.PCG","category":"page"},{"location":"solvers-preconditioners/#Solver-configuration","page":"Solvers and preconditioners","title":"Solver configuration","text":"","category":"section"},{"location":"solvers-preconditioners/","page":"Solvers and preconditioners","title":"Solvers and preconditioners","text":"Settings are passed as keyword arguments, with the names matching directly to HYPRE_SolverSet* calls from the HYPRE C API (see example below). Most settings are passed directly to HYPRE, for example Tol = 1e-9 would be passed directly to HYPRE_SolverSetTol for the correponding solver.","category":"page"},{"location":"solvers-preconditioners/","page":"Solvers and preconditioners","title":"Solvers and preconditioners","text":"Setting a preconditioner can be done by passing a HYPRESolver directly with the Precond keyword argument, without any need to also pass the corresponding HYPRE_SolverSetup and HYPRE_SolverSolve as must be done in the C API. In addition, solvers that have required settings when used as a preconditioner will have those applied automatically.","category":"page"},{"location":"solvers-preconditioners/","page":"Solvers and preconditioners","title":"Solvers and preconditioners","text":"HYPRE.jl adds finalizers to the solvers, which takes care of calling the their respective HYPRE_SolverDestroy function when the solver is garbage collected.","category":"page"},{"location":"solvers-preconditioners/#Example:-Conjugate-gradient-with-algebraic-multigrid-preconditioner","page":"Solvers and preconditioners","title":"Example: Conjugate gradient with algebraic multigrid preconditioner","text":"","category":"section"},{"location":"solvers-preconditioners/","page":"Solvers and preconditioners","title":"Solvers and preconditioners","text":"Here is an example of creating a PCG (conjugate gradient) solver with BoomerAMG (algebraic multigrid) as preconditioner:","category":"page"},{"location":"solvers-preconditioners/","page":"Solvers and preconditioners","title":"Solvers and preconditioners","text":"# Setup up linear system\nA = HYPREMatrix(...)\nb = HYPREVector(...)\n\n# Preconditioner\nprecond = HYPRE.BoomerAMG(; RelaxType = 6, CoarsenType = 6)\n\n# Solver\nsolver = HYPRE.PCG(; MaxIter = 1000, Tol = 1e-9, Precond = precond)\n\n# Solve\nx = HYPRE.solve(solver, A, b)","category":"page"},{"location":"solvers-preconditioners/","page":"Solvers and preconditioners","title":"Solvers and preconditioners","text":"Note that Tol = 0.0 and MaxIter = 1 are required settings when using BoomerAMG as a preconditioner. These settings are added automatically since it is passed as a preconditioner to the PCG solver.","category":"page"},{"location":"solvers-preconditioners/","page":"Solvers and preconditioners","title":"Solvers and preconditioners","text":"not: Corresponding C code\nFor comparison between the APIs, here is the corresponding C code for setting up the solver above:/* Setup linear system */\nHYPRE_IJMatrix A;\nHYPRE_IJVector b, x;\n\n/* Preconditioner */\nHYPRE_Solver precond;\nHYPRE_BoomerAMGCreate(&precond);\nHYPRE_BoomerAMGSetCoarsenType(precond, 6);\nHYPRE_BoomerAMGSetRelaxType(precond, 6);\nHYPRE_BoomerAMGSetTol(precond, 0.0);\nHYPRE_BoomerAMGSetMaxIter(precond, 1);\n\n/* Solver */\nHYPRE_Solver solver;\nHYPRE_ParCSRPCGCreate(MPI_COMM_WORLD, &solver);\nHYPRE_PCGSetMaxIter(solver, 1000);\n\n/* Add preconditioner */\nHYPRE_PCGSetPrecond(solver, (HYPRE_PtrToSolverFcn) HYPRE_BoomerAMGSolve,\n                            (HYPRE_PtrToSolverFcn) HYPRE_BoomerAMGSetup, precond);\n\n/* Solve */\nHYPRE_ParCSRPCGSetup(solver, A, b, x);\nHYPRE_ParCSRPCGSolve(solver, A, b, x);","category":"page"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"EditURL = \"https://github.com/Ferrite-FEM/Ferrite.jl/blob/master/CHANGELOG.md\"","category":"page"},{"location":"changelog/#HYPRE.jl-changelog","page":"Changelog","title":"HYPRE.jl changelog","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"All notable changes to this project will be documented in this file.","category":"page"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"changelog/#[Unreleased]","page":"Changelog","title":"[Unreleased]","text":"","category":"section"},{"location":"changelog/#Changed","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"PartitionedArrays.jl dependency upgraded from release series 0.3.x to release series 0.5.x. (#17, #18)\nCEnum.jl dependency upgraded to release series 0.5.x (release series 0.4.x still allowed). (#17, #18)\nPartitionedArrays.jl support (PSparseMatrix, PVector) is now moved to a package extension. (#23)\nSparseMatricesCSR.jl support (SparseMatrixCSR) is now moved to a package extension. (#24)\nSparseArrays.jl support (SparseMatrixCSC) is now moved to a package extension. (#25)","category":"page"},{"location":"changelog/#[v1.5.0](https://github.com/Ferrite-FEM/Ferrite.jl/releases/tag/v1.5.0)-2023-05-26","page":"Changelog","title":"v1.5.0 - 2023-05-26","text":"","category":"section"},{"location":"changelog/#Changed-2","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"PartitionedArrays.jl dependency upgraded from version 0.2.x to version 0.3.x. (#16)","category":"page"},{"location":"changelog/#[v1.4.0](https://github.com/Ferrite-FEM/Ferrite.jl/releases/tag/v1.4.0)-2023-01-20","page":"Changelog","title":"v1.4.0 - 2023-01-20","text":"","category":"section"},{"location":"changelog/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"New function HYPRE.GetFinalRelativeResidualNorm(s::HYPRESolver) for getting the final residual norm from a solver. This function dispatches on the solver to the corresponding C API wrapper LibHYPRE.HYPRE_${Solver}GetFinalRelativeResidualNorm. (#14)\nNew function HYPRE.GetNumIterations(s::HYPRESolver) for getting the number of iterations from a solver. This function dispatches on the solver to the corresponding C API wrapper LibHYPRE.HYPRE_${Solver}GetNumIterations. (#14)","category":"page"},{"location":"changelog/#[v1.3.1](https://github.com/Ferrite-FEM/Ferrite.jl/releases/tag/v1.3.1)-2023-01-14","page":"Changelog","title":"v1.3.1 - 2023-01-14","text":"","category":"section"},{"location":"changelog/#Fixed","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Solvers now keep an reference to the added preconditioner to make sure the preconditioner is not finalized before the solver. This fixes crashes (segfaults) that could happen in case no other reference to the preconditioner existed in the program. (#12)\nThe proper conversion methods for ccall are now defined for HYPREMatrix, HYPREVector, and HYPRESolver such that they can be passed direcly to HYPRE_* functions and let ccall guarantee the GC preservation of these objects. Although not observed in practice, this fixes a possible race condition where the matrix/vector/solver could be finalized too early. (#13)","category":"page"},{"location":"changelog/#[v1.3.0](https://github.com/Ferrite-FEM/Ferrite.jl/releases/tag/v1.3.0)-2022-12-30","page":"Changelog","title":"v1.3.0 - 2022-12-30","text":"","category":"section"},{"location":"changelog/#Added-2","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Rectangular matrices can now be assembled by the new method HYPRE.assemble!(::HYPREMatrixAssembler, i::Vector, j::Vector, a::Matrix) where i are the rows and j the columns. (#7)","category":"page"},{"location":"changelog/#Fixed-2","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"All created HYPRE objects (HYPREMatrix, HYPREVector, and HYPRESolvers) are now kept track of internally and explicitly finalized (if they haven't been GC'd) before finalizing HYPRE. This fixes a \"race condition\" where MPI and/or HYPRE would finalize before these Julia objects are garbage collected and finalized. (#8)","category":"page"},{"location":"changelog/#Deprecated","page":"Changelog","title":"Deprecated","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"The method HYPRE.assemble!(A::HYPREMatrixAssembler, ij::Vector, a::Matrix) have been deprecated in favor of HYPRE.assemble!(A::HYPREMatrixAssembler, i::Vector, j::Vector, a::Matrix), i.e. it is now required to explicitly pass rows and column indices individually. The motivation behind this is to support assembling of rectangular matrices. Note that HYPRE.assemble!(A::HYPREAssembler, ij::Vector, a::Matrix, b::Vector) is still supported, where ij are used as row and column indices for a, as well as row indices for b. (#6)","category":"page"},{"location":"changelog/#[v1.2.0](https://github.com/Ferrite-FEM/Ferrite.jl/releases/tag/v1.2.0)-2022-10-12","page":"Changelog","title":"v1.2.0 - 2022-10-12","text":"","category":"section"},{"location":"changelog/#Added-3","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Added assembler interface to assemble HYPREMatrix and/or HYPREVector directly without an intermediate sparse structure in Julia. (#5)","category":"page"},{"location":"changelog/#[v1.1.0](https://github.com/Ferrite-FEM/Ferrite.jl/releases/tag/v1.1.0)-2022-10-05","page":"Changelog","title":"v1.1.0 - 2022-10-05","text":"","category":"section"},{"location":"changelog/#Added-4","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Added support for MPI.jl version 0.20.x (in addition to the existing version 0.19.x support). (#2)","category":"page"},{"location":"changelog/#[v1.0.0](https://github.com/Ferrite-FEM/Ferrite.jl/releases/tag/v1.0.0)-2022-07-28","page":"Changelog","title":"v1.0.0 - 2022-07-28","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Initial release of HYPRE.jl.","category":"page"},{"location":"#HYPRE.jl","page":"Home","title":"HYPRE.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HYPRE.jl is a Julia wrapper for the HYPRE library, which provide parallel solvers for sparse linear systems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#High-level-interface","page":"Home","title":"High level interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HYPRE.jl provide a high level interface to the HYPRE library. The goal of this interface is that the style and API should feel natural to most Julia programmers (it is \"Julian\"). In particular, you can use standard sparse matrices together with HYPRE's solvers through this interface.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The high level interface does not (currently) provide access to all of HYPREs functionality, but it can easily be combined with the low level interface when necessary.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Low-level-interface","page":"Home","title":"Low level interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HYPRE.jl also provide a low level interface for interacting with HYPRE. The goal of this interface is to stay close to the HYPRE C API. In fact, this interface is automatically generated based on HYPRE's header files, so this API maps one-to-one with the C API, see LibHYPRE C API for more details.","category":"page"},{"location":"libhypre/#LibHYPRE-C-API","page":"LibHYPRE C API","title":"LibHYPRE C API","text":"","category":"section"},{"location":"libhypre/","page":"LibHYPRE C API","title":"LibHYPRE C API","text":"The submodule HYPRE.LibHYPRE contains auto-generated bindings to the HYPRE library and give access to the HYPRE C API directly[1]. The module exports all HYPRE_* symbols. Function names and arguments are identical to the C-library – refer to the HYPRE manual for details.","category":"page"},{"location":"libhypre/","page":"LibHYPRE C API","title":"LibHYPRE C API","text":"The example program examples/ex5.jl is an (almost) line-to-line translation of the corresponding example program examples/ex5.c written in C, and showcases how HYPRE.jl can be used to interact with the HYPRE library directly.","category":"page"},{"location":"libhypre/","page":"LibHYPRE C API","title":"LibHYPRE C API","text":"Functions from the LibHYPRE submodule can be used together with the high level interface. This is useful when you need some functionality from the library which isn't exposed in the high level interface. Many functions require passing a reference to a matrix/vector or a solver. HYPRE.jl defines the appropriate conversion methods used by ccall such that","category":"page"},{"location":"libhypre/","page":"LibHYPRE C API","title":"LibHYPRE C API","text":"A::HYPREMatrix can be passed to HYPRE_* functions with HYPRE_IJMatrix or HYPRE_ParCSRMatrix in the signature\nb::HYPREVector can be passed to HYPRE_* functions with HYPRE_IJVector or HYPRE_ParVector in the signature\ns::HYPRESolver can be passed to HYPRE_* functions with HYPRE_Solver in the signature","category":"page"},{"location":"libhypre/","page":"LibHYPRE C API","title":"LibHYPRE C API","text":"[1]: Bindings are generated using   Clang.jl, see   gen/generator.jl.","category":"page"}]
}
