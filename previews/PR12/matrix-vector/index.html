<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Matrix/vector representation · HYPRE.jl</title><meta name="title" content="Matrix/vector representation · HYPRE.jl"/><meta property="og:title" content="Matrix/vector representation · HYPRE.jl"/><meta property="twitter:title" content="Matrix/vector representation · HYPRE.jl"/><meta name="description" content="Documentation for HYPRE.jl."/><meta property="og:description" content="Documentation for HYPRE.jl."/><meta property="twitter:description" content="Documentation for HYPRE.jl."/><meta property="og:url" content="https://fredrikekre.github.io/HYPRE.jl/stable/matrix-vector/"/><meta property="twitter:url" content="https://fredrikekre.github.io/HYPRE.jl/stable/matrix-vector/"/><link rel="canonical" href="https://fredrikekre.github.io/HYPRE.jl/stable/matrix-vector/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">HYPRE.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Matrix/vector representation</a><ul class="internal"><li><a class="tocitem" href="#Direct-assembly-(multi-/single-process)"><span>Direct assembly (multi-/single-process)</span></a></li><li><a class="tocitem" href="#Create-from-PartitionedArrays.jl-(multi-process)"><span>Create from PartitionedArrays.jl (multi-process)</span></a></li><li><a class="tocitem" href="#Create-from-SparseMatrixCSC-/-SparseMatrixCSR-(single-process)"><span>Create from <code>SparseMatrixCSC</code> / <code>SparseMatrixCSR</code> (single-process)</span></a></li></ul></li><li><a class="tocitem" href="../solvers-preconditioners/">Solvers and preconditioners</a></li><li><a class="tocitem" href="../libhypre/">LibHYPRE C API</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Matrix/vector representation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Matrix/vector representation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/fredrikekre/HYPRE.jl" title="View the repository on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/fredrikekre/HYPRE.jl/blob/master/docs/src/matrix-vector.md" title="Edit source on GitHub"><span class="docs-icon fas"></span></a><a class="docs-settings-button docs-navbar-link fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button docs-navbar-link fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Matrix/vector-representation"><a class="docs-heading-anchor" href="#Matrix/vector-representation">Matrix/vector representation</a><a id="Matrix/vector-representation-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix/vector-representation" title="Permalink"></a></h1><p>HYPRE.jl defines the structs <code>HYPREMatrix</code> and <code>HYPREVector</code> representing HYPREs datastructures. Specifically it uses the <a href="https://hypre.readthedocs.io/en/latest/api-int-ij.html">IJ System Interface</a> which can be used for general sparse matrices.</p><p><code>HYPREMatrix</code> and <code>HYPREVector</code> can be constructed either by assembling directly, or by first assembling into a Julia datastructure and the converting it. These various methods are outlined in the following sections:</p><ul><li><a href="#Direct-assembly-(multi-/single-process)">Direct assembly (multi-/single-process)</a></li><li><a href="#Create-from-PartitionedArrays.jl-(multi-process)">Create from PartitionedArrays.jl (multi-process)</a></li><li><a href="#Create-from-SparseMatrixCSC-/-SparseMatrixCSR-(single-process)">Create from <code>SparseMatrixCSC</code> / <code>SparseMatrixCSR</code> (single-process)</a></li></ul><h2 id="Direct-assembly-(multi-/single-process)"><a class="docs-heading-anchor" href="#Direct-assembly-(multi-/single-process)">Direct assembly (multi-/single-process)</a><a id="Direct-assembly-(multi-/single-process)-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-assembly-(multi-/single-process)" title="Permalink"></a></h2><p>Creating <code>HYPREMatrix</code> and/or <code>HYPREVector</code> directly is possible by first creating an assembler which is used to add all individual contributions to the matrix/vector. The required steps are:</p><ol><li>Create a new matrix and/or vector using the constructor.</li><li>Create an assembler and initialize the assembling procedure using <a href="../api/#HYPRE.start_assemble!"><code>HYPRE.start_assemble!</code></a>.</li><li>Assemble all non-zero contributions (e.g. element matrix/vector in a finite element simulation) using <a href="../api/#HYPRE.assemble!"><code>HYPRE.assemble!</code></a>.</li><li>Finalize the assembly using <a href="../api/#HYPRE.finish_assemble!"><code>HYPRE.finish_assemble!</code></a>.</li></ol><p>After these steps the matrix and vector are ready to pass to the solver. In case of multiple consecutive solves with the same sparsity pattern (e.g. multiple Newton steps, multiple time steps, ...) it is possible to reuse the same matrix by simply skipping the first step above.</p><p><strong>Example pseudocode</strong></p><pre><code class="language-julia hljs"># MPI communicator
comm = MPI.COMM_WORLD # MPI.COMM_SELF for single-process setups

# Create empty matrix and vector -- this process owns rows ilower to iupper
A = HYPREMatrix(comm, ilower, iupper)
b = HYPREVector(comm, ilower, iupper)

# Create assembler
assembler = HYPRE.start_assemble!(A, b)

# Assemble contributions from all elements owned by this process
for element in owned_elements
    Ae, be = compute_element_contribution(...)
    global_indices = get_global_indices(...)
    HYPRE.assemble!(assembler, global_indices, Ae, be)
end

# Finalize the assembly
A, b = HYPRE.finish_assemble!(assembler)</code></pre><h2 id="Create-from-PartitionedArrays.jl-(multi-process)"><a class="docs-heading-anchor" href="#Create-from-PartitionedArrays.jl-(multi-process)">Create from PartitionedArrays.jl (multi-process)</a><a id="Create-from-PartitionedArrays.jl-(multi-process)-1"></a><a class="docs-heading-anchor-permalink" href="#Create-from-PartitionedArrays.jl-(multi-process)" title="Permalink"></a></h2><p>HYPRE.jl integrates seemlessly with <code>PSparseMatrix</code> and <code>PVector</code> from the <a href="https://github.com/fverdugo/PartitionedArrays.jl">PartitionedArrays.jl</a> package. These can be passed directly to <code>solve</code> and <code>solve!</code>. Internally this will construct a <code>HYPREMatrix</code> and <code>HYPREVector</code>s and then convert the solution back to a <code>PVector</code>.</p><p>The <code>HYPREMatrix</code> constructor support both <code>SparseMatrixCSC</code> and <code>SparseMatrixCSR</code> as storage backends for the <code>PSparseMatrix</code>. However, since HYPREs internal storage is also CSR based it can be <em>slightly</em> more resource efficient to use <code>SparseMatrixCSR</code>.</p><p>The constructors also support both PartitionedArrays.jl backends: When using the <code>MPI</code> backend the communicator of the <code>PSparseMatrix</code>/<code>PVector</code> is used also for the <code>HYPREMatrix</code>/<code>HYPREVector</code>, and when using the <code>Sequential</code> backend it is assumed to be a single-process setup, and the <code>MPI.COMM_SELF</code> communicator is used.</p><p><strong>Example pseudocode</strong></p><pre><code class="language-julia hljs"># Assemble linear system (see documentation for PartitionedArrays)
A = PSparseMatrix(...)
b = PVector(...)

# Solve with zero initial guess
x = solve(solver, A, b)

# Inplace solve with x as initial guess
x = PVector(...)
solve!(solver, x, A, b)</code></pre><hr/><p>It is also possible to construct the arrays explicitly. This can save some resources when performing multiple consecutive solves (multiple time steps, Newton iterations, etc). To copy data back and forth between <code>PSparseMatrix</code>/<code>PVector</code> and <code>HYPREMatrix</code>/<code>HYPREVector</code> use the <code>copy!</code> function.</p><p><strong>Example pseudocode</strong></p><pre><code class="language-julia hljs">A = PSparseMatrix(...)
x = PVector(...)
b = PVector(...)

# Construct the HYPRE arrays
A_h = HYPREMatrix(A)
x_h = HYPREVector(x)
b_h = HYPREVector(b)

# Solve
solve!(solver, x_h, A_h, b_h)

# Copy solution back to x
copy!(x, x_h)</code></pre><h2 id="Create-from-SparseMatrixCSC-/-SparseMatrixCSR-(single-process)"><a class="docs-heading-anchor" href="#Create-from-SparseMatrixCSC-/-SparseMatrixCSR-(single-process)">Create from <code>SparseMatrixCSC</code> / <code>SparseMatrixCSR</code> (single-process)</a><a id="Create-from-SparseMatrixCSC-/-SparseMatrixCSR-(single-process)-1"></a><a class="docs-heading-anchor-permalink" href="#Create-from-SparseMatrixCSC-/-SparseMatrixCSR-(single-process)" title="Permalink"></a></h2><p>HYPRE.jl also support working directly with <code>SparseMatrixCSC</code> (from the <a href="https://github.com/JuliaSparse/SparseArrays.jl">SparseArrays.jl</a> standard library) and <code>SparseMatrixCSR</code> (from the <a href="https://github.com/gridap/SparseMatricesCSR.jl">SparseMatricesCSR.jl</a> package). This makes it possible to use solvers and preconditioners even for single-process problems. When using these type of spars matrices it is assumed that the right hand side and solution vectors are regular Julia <code>Vector</code>s.</p><p>Just like when using the PartitionedArrays.jl package, it is possible to pass sparse matrices directly to <code>solve</code> and <code>solve!</code>, but it is also possible to create <code>HYPREMatrix</code> and <code>HYPREVector</code> explicitly, possibly saving some resources when doing multiple consecutive linear solves (see previous section).</p><p><strong>Example pseudocode</strong></p><pre><code class="language-julia hljs">A = SparseMatrixCSC(...)
x = Vector(...)
b = Vector(...)

# Solve with zero initial guess
x = solve(solver, A, b)

# Inplace solve with x as initial guess
x = zeros(length(b))
solve!(solver, x, A, b)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../solvers-preconditioners/">Solvers and preconditioners »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.28.0-DEV on <span class="colophon-date" title="Friday 13 January 2023 09:24">Friday 13 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
